### What is D3M-PIN?

D3M-PIN is the abbreviation of Distributed Multiparty Mobile Mixin PIN. Simply put, it is a distributed multi-party mobile hybrid PIN code technology. Different from the simple centralized 6-digit password that everyone sees in traditional centralized applications, D3M-PIN is a distributed password solution that is jointly guaranteed by participants in different roles.

D3M-PIN 是 Distributed Multiparty Mobile Mixin PIN 的缩写，简单来说就是分布式的多方移动混合 PIN 码技术。不同于传统的中心化应用中大家看到的简单的中心化的 6 位数字密码，D3M-PIN 是由不同角色的参与方共同保障的分布式的密码解决方案。

The main participants in D3M-PIN include the user (U), trusted registrar (M) and trusted distributed ledger (L). The three D3M-PIN participants cooperate with each other to achieve sufficient decentralization, security and credibility, while at the same time ensuring that the user experience is the simplest.

在 D3M-PIN 中主要的参与方包括使用者（U）、可信注册服务商（M）和可信分布式账本（L）。三个 D3M-PIN 参与者相互协作，在每一个环节都能做到足够的去中心化安全可信，同时又能保障使用者的使用体验最简单。

User (U) refers to the specific user of Mixin Messenger. It may be a real person or a robot, and they are not associated with a specific device. The user’s responsibility is to remember his 6-digit PIN code, which is simple and convenient enough. This PIN code is part of the overall private key scheme.

使用者（U）指的主要是 Mixin Messenger 的具体使用者，可能是一个真实的人，也可能是一份机器人代码，他们不与具体的设备相关联。使用者的职责是记住自己的 6 位数字 PIN 码，足够简单方便，这个 PIN 码是整体私钥方案中的一部分。

A trusted registrar (M) refers to a service provider that provides SMS verification codes. One example is the server connected by Mixin Messenger. The main responsibility of the registrar is to help users synchronize another part of the private key scheme.

可信注册服务商（M）是指提供短信验证码的服务商，最直观的一种就是 Mixin Messenger 连接的服务器。注册服务商的主要职责是帮助使用者同步私钥方案的另一部分。

Distributed ledger (L) is a distributed ledger network that uses open and trusted computing. The most typical is the PoS consensus BFT-DAG network provided by Mixin Network.

分布式账本（L）是采用了公开可信计算的分布式账本网络，最典型的就是 Mixin Network 提供的 PoS 共识的 BFT-DAG 网络。分布式账本通过完全去中心化的手段帮助使用者托管并计算完整的多签私钥。

## D3M-PIN Computation Process
Every user who uses Mixin Messenger will have a mainnet multi-signature private key on Mixin Kernel. For the convenience of explanation, we have the following assumptions and conventions:

### D3M-PIN 的计算流程
每一个使用 Mixin Messenger 的用户都会拥有一个 Mixin Kernel 上的主网多重签名私钥，为方便说明我们有下面的假设与约定：

- The number of nodes in L is n, and we assume that U's multi-signature private key also needs exactly these n nodes to complete, and these n nodes are fixed and unchanged.

- L 的节点数量为 n 个，并且我们假设 U 的多重签名私钥也正好完全需要这 n 个节点来完成，并且这 n 个节点固定不发生变化。

- 1...n represents the relevant parameters of the 1st to the nth node in turn, for example, L7 represents the unique public key of the main network of the 7th node, and l7 represents the corresponding private key of *L7.

- 1…n 依次代表第 1 到第 n 个节点的相关参数，比如 L7 代表第 7 个节点的主网唯一公钥，l7 代表 *L7 的对应私钥。

- PIN is a 6-digit password selected by the user, and the 6-digit password is fixed and unchanged.

- PIN 是用户选定的 6 位数字密码，并且这 6 位数字密码固定不发生变化。

- Hs is a cryptographic hash algorithm, which can always generate the same result deterministically for the same input, and there is no conflict.

- Hs 是一个加密哈希算法，对同样的输入总是可以确定性的生成同样的结果，并且没有冲突。

- I is a standard UUID randomly generated by M to represent a unique account information.

- I 是 M 随机生成的一个标准的 UUID，用来代表一个唯一的账户信息。

- m is a key kept privately by M, which does not change with M's life cycle.

- m 是一个确定的由 M 私密保管的密钥，这个密钥伴随 M 的生命周期固定不发生变化。

- Fs(a,X) is the standard EdDSA signature algorithm, which represents the use of the private key a to sign the message X.

- Fs(a,X) 是标准的 EdDSA 签名算法，代表使用私钥 a 对消息 X 进行签名。

- If a represents an EdDSA private key, then aG represents the corresponding public key.

- 如果 a 代表一个 EdDSA 的私钥，那么 aG 代表相应的公钥。

With the above definition, let’s see how a user can safely use a phone number and a 6-digit PIN to complete a transaction:

1. When U log in Mixin Messenger for the first time on a device, an account information I can be associated with U through M's SMS verification code service.
2. M will generate n one-to-one corresponding verification seeds through si = Hs(I || m || Li) for each node in L.
3. For each newly generated seed si, M needs to send a unique Mixin Kernel transaction Ti to the corresponding siG.
4. M returns all n verification seeds from s1 to sn and the corresponding Ti to the current device and saves them on the device. U can choose to back up all si.
5. U If it is the first time to register an account, he needs to use si to sign the corresponding Ti to verify the uniqueness of si to your account on the mainnet.
6. For each node in L, U generates n certain one-to-one private keys ui = Hs(PIN || si || Li).
7. For each private key ui, U generates a signature Si = Fs(ui,Hs(Li || "COMMIT")), and sends Si and the corresponding public key uiG to each node Li.
8. After verifying the correctness of Si, node Li returns an error code or returns the corresponding new public key piG to U, where pi = Hs(uiG || li).
9. After U has collected enough n new public keys, he can get his complete multi-signature public key on the mainnet P = p1G + p2G +… + pnG.
10. When he needs to use one of its own UTXOs, firstly he will generate the corresponding transaction T, then sign Si = Fs(ui,Hs(Li || Hs(T))), and send Si and uiG to each node Li .
11. After verifying the correctness of Si, node Li returns an error code or returns a corresponding new signature Si = Fs(Hs(uiG || li),Hs(T)) to U.
12. After U has collected enough n new signatures, the complete multi-signature S = S1 + S2 +… + Sn of transaction T can be obtained.
The most critical point in this process is that node Li has a strict limit on the number of requests for verification of each signature request.


有了上面的定义，我们来看一个用户是如何安全的使用电话号码和 6 位数字 PIN 码来完成一笔交易的：

1. 当 U 第一次在某个设备上使用 Mixin Messenger 登录时，通过 M 的短信验证码服务可以关联一个账户信息 I。
2. M 会针对每一个 L 中的节点，通过 si = Hs(I || m || Li) 生成一一对应的 n 个验证种子。
3. 对于每一个新生成的种子 si，M 都需要发送唯一一笔 Mixin Kernel 的交易 Ti 到相应的 siG。
4. M 将 s1 到 sn 共 n 个验证种子以及相应的 Ti 全部返回给当前设备并保存在设备上，U 可以选择备份所有 si。
5. U 如果是第一次注册账号，需要使用 si 将相应的 Ti 签名，来验证 si 在主网对于自己账号的唯一性。
6. U 对每一个 L 中的节点，生成确定的一一对应的 n 个私钥 ui = Hs(PIN || si || Li)。
7. 对于每一个私钥 ui，U 生成签名 Si = Fs(ui,Hs(Li || “COMMIT”))，并将 Si 与对应的公钥 uiG 发送给每一个节点 Li。
8. 节点 Li 通过验证 Si 的正确性，返回错误码或者给 U 返回对应的新公钥 piG，其中 pi = Hs(uiG || li)。
9. 当 U 收集到足够的 n 个新公钥后，可以得到自己在主网的完整的多重签名公钥 P = p1G + p2G + … + pnG。
10. 当 U 需要使用自己的一个 UTXO 时，首先生成相应的交易 T，然后签名 Si = Fs(ui,Hs(Li || Hs(T)))，并将 Si 与 uiG 发送给每一个节点 Li。
11. 节点 Li 通过验证 Si 的正确性，返回错误码或者给 U 返回对应的新签名 Si = Fs(Hs(uiG || li),Hs(T))。
12. 当 U 收集到足够的 n 个新签名后，可以得到交易 T 的完整多重签名 S = S1 + S2 + … + Sn。
这个流程中最关键的一点在于节点 Li 对每一次签名请求的验证都是有严格的请求次数限制的。

### Security Proof of D3M-PIN
We will analyze and prove the possible risks in the overall process of D3M-PIN to show that this solution is safe, reliable and completely decentralized. Since the user U and the distributed ledger L are already a secure decentralized solution, the following analysis is only for the possible problems of the registrar M.

- Since M may only have one operator, if he no longer operates, will the user's assets still be safe?

Obviously it is safe. First, the registrar usually allows users to download data when they are no longer operating. At this time, users have enough time to save their private key seed si; secondly and most importantly, after the user obtains the si , There is a corresponding copy on the device, even if M is closed, it will not affect the use of si; finally, the user can back up all si at any time, so that regardless of whether M is closed or not, the user no longer needs to use the SMS verification code to trade at any time or switch devices.

-If the phone number is lost, how can users access their assets?

Firstly, M provides emergency contact services. After any user loses phone number access rights, he can obtain his own private key seed si through the emergency contact. Secondly, people can go to the telecom operator, authenticate their identity to obtain access to their phone number again. Finally, according to the analysis in question 1, the user device has a copy of si, so that regardless of whether there is phone number access permission, users no longer need to use SMS verification codes to trade or switch devices.

- If someone else gets access to the user's phone number, are his assets still safe?

After the attacker obtains the phone number access authority, he actually obtained the user's private key seed si. We assume that the attacker is the registrar M, which obviously has the private key seed of all users. Because M does not know the user's PIN, and the PIN has a total of 1 million possibilities due to the 6-digit design. Assuming a total of 30 nodes, each node has a fixed limit of 5 trial and error signature verification times per day, so the time required for M to brute force 1 million possibilities is at least 1000000/30/5/365 = 18 years . Therefore, even if M itself acts as an attacker, it is extremely difficult to steal user assets. If the use of the signature random counter is increased, the probability of being cracked will immediately become zero.

In summary, in any possible situation, the user's assets will be safe and accessible.

### D3M-PIN 的安全证明
我们将对 D3M-PIN 的整体流程中存在的可能风险进行相应的分析与证明，来说明本方案是安全可靠并且完全去中心化的。由于使用者 U 和分布式账本 L 已经是安全的去中心化方案，下面的分析仅针对注册服务商 M 可能存在的问题。

- 由于 M 可能只有一个运营商，如果他不再运营，那使用者的资产还是安全的吗？
显然是安全的，首先注册服务商不再运营时通常会允许用户下载数据，这时使用者有足够的时间来保存自己的私钥种子 si；其次也是最重要的，使用者在获取到 si 之后，设备上已经有相应副本，即使 M 关闭也不影响 si 的使用；最后，使用者可以随时备份所有的 si，这样不论 M 关闭与否，用户都不再需要使用短信验证码就可以随时交易以及切换设备。
- 如果电话号码丢失，使用者如何访问自己的资产？
首先 M 有提供紧急联系人服务，每一个使用者丧失电话号码访问权限后，都可以通过紧急联系人来获取自己的私钥种子 si；其次一般人的电话号码都可以到电信运营商处重新通过身份认证获得访问权限；最后就像问题 1 中分析的一样，用户设备有 si 的副本并且可以备份 si，这样无论有没有电话号码访问权限，用户都不再需要使用短信验证码就可以随时交易以及切换设备。
- 如果别人拿到了使用者的电话号码访问权限，那他的资产还是安全的吗？
攻击者拿到电话号码访问权限之后，实际上是得到了使用者的私钥种子 si，我们不防假定这个攻击者就是注册服务商 M，它显然拥有所有使用者的私钥种子。因为 M 并不知道使用者的 PIN，而 PIN 因为 6 位数字设计的限制，共计拥有 100 万个可能性。假设共计 30 个节点，每个节点对签名验证试错的次数限制是固定的每天 5 次，那么 M 尝试暴力破解 100 万个可能性所需要的时间最少是 1000000/30/5/365 = 18 年。所以即使 M 本身作为攻击者也是极难盗取使用者资产的。如果增加签名随机计数器的使用，那么被破解的可能性将马上变为 0。
综上所述，在任何可能的情况发生时，使用者的资产都会是安全可访问的。
